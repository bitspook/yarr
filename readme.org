* Yarr : Delegated Events

We have our pretty components system set up, but what about events? Users will be interacting with our app, right?
Since we're taking so much "inspiration" from React, how do React handle events? Really? You want to get into those "onClick" stuff? I mean they are pretty, I've nothing against them, but given a choice I won't really vouch for them either. That said, I don't want to get into "when a component is ready and when it's re-rendered" events either.

Another hint, Observable are good at chaining operations (dead give away, *filter*). What if we use delegated events? Like put an event listener on ~document.body~, and filter for the target we want? Let's try this. Let's create a counting button component (and remove other components from our previous step).

Our project shall look like this atm:

#+begin_src bash
.
├── index.html
├── package.json
├── src
│   ├── components
│   │   └── main.js
│   ├── index.js
│   └── renderer.js
└── webpack.config.js
#+end_src

Also wipe-up the `components/main.js`.

- *Count clicks Component*

Let's create a new component which will count the clicks we made to a button.

#+begin_src javascript
//components/count-clicks.js
import h from 'virtual-dom/h';
import {Observable} from 'rx';

let view = (count) =>
  <div className="count-clicks">
    <button className="count-clicks-btn">Click me!</button>
    <span style="font-size: 20px;">{count}</span>
  </div>

let render_ = () => {
  let count = 0;

  return Observable.
    return(view(count + ''));
}

export default render_;
#+end_src

And our ~components/main.js~ will be:

#+begin_src javascript
import h from 'virtual-dom/h';
import {Observable} from 'rx';

import countClicks_ from './count-clicks';

let view = (countClicks) => {
  return <div className="container">
    {countClicks}
  </div>;
}

let render_ = () => Observable
      .combineLatest(
        countClicks_(),
        view
      );

export default render_;
#+end_src

Great! Now we want to listen to click events on our ~.count-clicks-btn~. Virtual-DOM/React way of doing that is to provide a `onClick` handler in properties, but we don't want to do that. We want to use delegated events instead. Let's do that.

Create ~./src/events.js~ file. We'll host our source events code there, and make the events pass through a chain of Observable operators to get only the events we need.

#+begin_src javascript
//src/events.js
import {Observable} from 'rx';

let body = document.body;

let clicks_ = Observable.fromEvent(body, 'click');

let toArray = (arrayLike) => Array.prototype.slice.call(arrayLike, 0);

let countBtnClicks_ = clicks_
      .filter(e => {
        let classes = toArray(e.target.classList);

        return classes.indexOf('count-clicks-btn') >= 0;
      });


export {countBtnClicks_};
#+end_src

We have put a `click` event listener on body, and then we're filtering it by class name to get clicks only for our button. Let's import these events to our `countClicks` component and check by subscribing to it.

#+begin_src javascript
//components/count-clicks.js
.
.
.
import {countBtnClicks_} from '../events';
countBtnClicks_
  .subscribe(x => console.log(x));
#+end_src

Voilla! it's working. We'll use this system of delegated events in our app. Let's make `events.js` code more re-useable.

#+begin_src javascript
//events.js
import {Observable} from 'rx';

import {toArray} from './utils';


let body = document.body;

let clicks_ = Observable.fromEvent(body, 'click');


let clicksByClass_ = (className) => clicks_
      .filter(e => {
        let classes = toArray(e.target.classList);

        return classes.indexOf(className) >= 0;
      });


export {clicksByClass_};
#+end_src

#+begin_src javascript
//components/count-clicks.js
import h from 'virtual-dom/h';
import {Observable} from 'rx';

import {clicksByClass_} from '../events';

let view = (count) =>
    <div className="count-clicks">
      <button className="count-clicks-btn">Click me!</button>
      <span> {count}</span>
    </div>;

let render_ = () => {
  let count = 0;

  return Observable.
    return(view(count + ''));
}

clicksByClass_('count-clicks-btn')
  .subscribe(x => console.log(x));

export default render_;
#+end_src

And create a `src/utils.js` to keep small utility methods:

#+begin_src javascript
//src/utils.js
export default {
  toArray: (arrayLike) => Array.prototype.slice.call(arrayLike, 0)
}
#+end_src

Now that we have clicks as an Observable, we can use them to produce our `countClicks` component's view:

#+begin_src javascript
//components/count-clicks.js
import h from 'virtual-dom/h';
import {Observable} from 'rx';

import {clicksByClass_} from '../events';

let view = (count) =>
    <div className="count-clicks">
      <button className="count-clicks-btn">Click me!</button>
      <span> {count}</span>
    </div>;

let render_ = () => {
  let count = 0;

  let countBtnClicks_ = clicksByClass_('count-clicks-btn');

  return countBtnClicks_
    .map(e => ++count)
    .startWith(0) //nothing will get rendered if we take this away
    .map(n => n.toString())
    .map(view);
}

export default render_;
#+end_src

Our app is working! What kind of sorcery is this?

Honestly, if you were paying attention this won't look like sorcery at all. ~countBtnCicks_~ gives us a notification (in form of event) every time user clicks our button, we convert that to an incrementing count. Next is ~startWith(0)~, remember why we need it? Without startWith, our renderer will keep waiting for countBtnClicks_ to emit at least once (because we use `combineLatest` to combine all views), and countBtnClicks_ will emit only if user clicks on the button. But there is no button rendered yet! To get out of this loop, we start it with an initial value.

Great! With that out of the way, we have our component system and events system in place, we can finally start building our app. Lol, I lied to you like 2 steps back that we're building Yarr back then. Can't believe you fell for that you dumb fuck.

Just kidding, I don't really think you are a dumb fuck. Dumb fucks are cool.

Let's move to next step then.

#+begin_src bash
git checkout 5-fetch-feeds-and-styles
#+end_src
