* Yarr : Reactive Dexie

In this step we'll make our data sources (`feeds_` and `posts_`) reactive, and we'll see how easy it is to make your own Observable.

Take a look at ~src/models/feeds.js~. We are exporting:

#+begin_src javascript
let feeds_ = Observable
      .fromPromise(Feeds.toArray()).share();
#+end_src

which we then use as our source for feeds across our app. Basically just returning data straight from the dexie database. Now let's formulate what our requirements are for a *reactive* data source:

> Reactive data source should give us new data *whenever the data is added, removed or changed*

Dexie js provide us hooks for receiving events for exactly above 3 situations: https://github.com/dfahlander/Dexie.js/wiki/Table It even has a hook for /reading/, but we're not interested in that.

Now if we can convert these hooks to Observable, and merge them such that when any of the above 3 hooks fire, we re-fetch the data and make ~feeds_~ emit it again, our whole UI will update. That's what Observable are, right? Asynchronous push based collections.

- *Dexie hooks -> Observable*

  Let's start with making a helper function that will convert a hook into an Observable. Open up ~src/db.js~:

  #+begin_src javascript
  // db.js
  import {Observable} from 'rx';
  .
  .
  .
  let reactiveDexieTable_ = (table, hookName) => {
    return Observable.create((obs) => {
      let dbListener = table.hook(hookName, (pk, obj, txn, update) => {
        //Can't use `arguments` because webpack.
        //there are 4 arguments for 'updating' op, otherwise there are 3.
        //in case of 'updating' first arg is 'modifications', and other three are same
        obs.onNext(pk, obj, txn, update);
      });

      return () => {
        table.hook(hookName).unsubscribe(dbListener);
      };
    });

  };

  export default {
    db,
    Posts: db.posts,
    Feeds: db.feeds,
    reactiveDexieTable_
  };
  #+end_src

  ~reactiveDexieTable_~ shall give us an Observable for listening to one of ~creating~, ~updating~, ~deleting~ hooks on a dexie table.

  Creating an Observable is really simple. There's a helper method ~Observable.create~ which makes the job easier. ~Observable.create~ takes a function (call it `cb`) as argument. `cb` is given an Observer (call it `obs`) as argument. It's `cb`'s duty to call `obs`'s ~onNext~, ~onError~, ~onComplete~, when it does, that's when our resulting Observable will emit values/errors/onCompleted. `cb` shall return a function which will be called when it's time to dispose the Observable. Ideally, `cb`'s return function clears whatever resources our Observable used (it should remove event listeners it added for example).

  In our case, we don't want the resulting Observable to ever complete, so we don't have an ~obs.onCompleted~ call. And we don't have an ~obs.onError~ call, because bad developers don't handle errors. What? You really thought I am a good developer? Lol! Can't believe you fell for that. Actually I do believe that, I anticipated that; you're too predictable you know. Honestly, I didn't anticipated shit, I just had to be a smartass. You know what! I actually did anticipate that, but I had to be humble. Really honestly though, I /<smack>/...okay let's proceed. /You didn't need to hit me. You prick!/

- *Test reactive dexie table*

  Let's do a quick test run. We'll create an Observable for listening to `creating` hook, clear all the feeds, refresh the browser and see if this Observable emits. Put this anywhere in ~src/db.js~:
  #+begin_src javascript
  reactiveDexieTable_(db.feeds, 'creating')
    .do(x => console.log('WHOA! Hook is working!', x))
    .subscribe();
  #+end_src

  Open console in your browser, do a ~Feeds.clear()~ and ~Posts.clear()~, and refresh. If you see that =Whoa!= message, our new Observable is working. Awesome! Remove code added above.

- *Cascading delete for Posts*

  Let's do something little more useful. Noticed we had to clear both ~Feeds~ and ~Posts~ above (so re-adding ~Posts~ won't show an error). Keeping ~Posts~ in db don't make any sense when we've removed the `Feed` they belong to. Let's use our awesome new reactive table Observable and delete all the Posts that belong to the feed whenever we delete the feed.

  #+begin_src javascript
  .
  .
  .
  //delete all posts whenever a feed is deleted from dexie db
  reactiveDexieTable_(db.feeds, 'deleting')
    .flatMap(feedUrl => {
      return db.posts.where('feedUrl').equals(feedUrl).delete();
    })
    .subscribe(
      x => console.log(`${x} posts deleted successfully in cascading delete operation.`),
      e => console.error('Error while cascading Posts delete', e)
    );
  .
  .
  .
  #+end_src

  Now go to browser's console and do a ~Feeds.clear()~ again. You'll see ~N posts deleted~ messages, and if you refresh the page, you'll see Posts are all gone.

- *Reactive Feeds*

  That's all great, let's use this in our UI. We'll start with feeds. Open ~src/models/feeds.js~:

  #+begin_src javascript
  import {Feeds, reactiveDexieTable_} from '../db';
  .
  .
  .
  let feeds_ = Observable
        .merge(
          reactiveDexieTable_(Feeds, 'creating'),
          reactiveDexieTable_(Feeds, 'updating'),
          reactiveDexieTable_(Feeds, 'deleting')
        )
        .startWith('')
        .flatMap(() => Feeds.toArray()).share();

  export default {feeds_};
  #+end_src

  We create 3 Observable to inform us whenever ~Feeds~ are updated, deleted or added, and we ~Observable.merge~ them so that we get a notification when either one of these events happen. Can you guess why we did ~.startWith('')~ here? Without ~startWith~, the Observable will keep waiting for one of the 3 events to happen. We don't want that, we want to send feeds to our UI on initial refresh too, so we start with an empty notification, and send feeds every time page refreshes, and then we send them every time something happens in our ~Feeds~ table.

  Let's try it real quick. Open up the console in browser and do ~Feeds.clear()~. You'll see all the feeds from our feeds list in sidebar vanish. Is it awesome or what! If you refresh the page, feeds will get added back again on first refresh, however posts will not. That's expected, let's make Posts reactive too.

- *Reactive Posts*

  How do we make Posts reactive now? Exactly how we made Feeds reactive, dumbass!

  #+begin_src javascript
  // models/posts.js
  import {Posts, reactiveDexieTable_} from '../db';
  import {Observable} from 'rx';

  let posts_ = Observable
        .merge(
          reactiveDexieTable_(Posts, 'creating'),
          reactiveDexieTable_(Posts, 'updating'),
          reactiveDexieTable_(Posts, 'deleting')
        )
        .startWith('')
        .flatMap(() => Posts.orderBy('publishedDate').reverse().toArray());

  export default {posts_};
  #+end_src

  Now if you do ~Feeds.clear()~ in console, you'll see posts-list get all cleared too, and you might also see posts getting added dynamically when you refresh the page later.

  To delete a single post or feed from console, right click it in UI and /Copy Link Address/. Then in console you can do ~Posts.delete(link)~


Now that our offline database is reactive, bring our UI to life. In next step we'll add functionality to the control widgets in sidebar.

#+begin_src bash
git checkout 9-bring-ui-to-life
#+end_src
